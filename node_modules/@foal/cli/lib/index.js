#!/usr/bin/env node
"use strict";
/**
 * FoalTS
 * Copyright(c) 2017-2022 Lo√Øc Poullain <loic.poullain@centraliens.net>
 * Released under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// 3p
const safe_1 = require("colors/safe");
const commander_1 = require("commander");
// FoalTS
const create_secret_1 = require("./create-secret");
const generate_1 = require("./generate");
const file_system_1 = require("./generate/file-system");
const rmdir_1 = require("./rmdir");
const run_script_1 = require("./run-script");
function displayError(...lines) {
    console.error();
    lines.forEach(line => console.error((0, safe_1.red)(line)));
    console.error();
    process.exitCode = 1;
}
// tslint:disable-next-line:no-var-requires
const pkg = require('../package.json');
commander_1.program
    .version(pkg.version, '-v, --version');
commander_1.program
    .command('createapp')
    .argument('<name>', 'Name of the application')
    .description('Create a new project.')
    .option('-G, --no-git', 'Don\'t initialize a git repository')
    .option('-I, --no-install', 'Don\'t autoinstall packages using yarn or npm (uses first available)')
    .option('-m, --mongodb', 'Generate a new project using MongoDB instead of SQLite', false)
    .option('-y, --yaml', 'Generate a new project using YAML configuration instead of JSON', false)
    .action((name, options) => {
    (0, generate_1.createApp)({
        autoInstall: options.install,
        initRepo: options.git,
        mongodb: options.mongodb,
        name,
        yaml: options.yaml
    });
});
commander_1.program
    .command('createsecret')
    .description('Create a 256-bit random secret encoded in base64.')
    .action(() => (0, create_secret_1.createSecret)().then(secret => console.log(secret)));
commander_1.program
    .command('run')
    .argument('<name>', 'Name of the script to run')
    .alias('run-script')
    .description('Run a shell script.')
    .action((name) => {
    (0, run_script_1.runScript)({ name }, process.argv);
});
commander_1.program
    .command('connect')
    .argument('<framework>', 'Frontend framework to connect to')
    .argument('<path>', 'Path to the frontend project')
    .description('Configure your frontend to interact with your application.')
    .addHelpText('after', `
Available frameworks:
  - angular
  - react
  - vue
  `)
    .action(async (framework, path) => {
    switch (framework) {
        case 'angular':
            (0, generate_1.connectAngular)(path);
            break;
        case 'react':
            (0, generate_1.connectReact)(path);
            break;
        case 'vue':
            (0, generate_1.connectVue)(path);
            break;
        default:
            displayError(`Unknown framework ${(0, safe_1.yellow)(framework)}. Please provide a valid one:`, '', '  - angular', '  - react', '  - vue');
    }
});
const generateTypes = [
    'controller', 'entity', 'rest-api', 'hook', 'script', 'service'
];
commander_1.program
    .command('generate')
    .argument('<type>', 'Type of the file to generate')
    .argument('<name>', 'Name of the file to generate')
    .description('Generate and/or modify files.')
    .option('-r, --register', 'Register the controller into app.controller.ts (only available if type=controller|rest-api)', false)
    .option('-a, --auth', 'Add an owner to the entities of the generated REST API (only available if type=rest-api)', false)
    .alias('g')
    .addHelpText('after', `
Available types:
${generateTypes.map(t => `  - ${t}`).join('\n')}
  `)
    .action(async (type, name, options) => {
    try {
        switch (type) {
            case 'controller':
                (0, generate_1.createController)({ name, register: options.register });
                break;
            case 'entity':
                (0, generate_1.createEntity)({ name });
                break;
            case 'rest-api':
                (0, generate_1.createRestApi)({ name, register: options.register, auth: options.auth });
                break;
            case 'hook':
                (0, generate_1.createHook)({ name });
                break;
            case 'script':
                (0, generate_1.createScript)({ name });
                break;
            case 'service':
                (0, generate_1.createService)({ name });
                break;
            default:
                displayError(`Unknown type ${(0, safe_1.yellow)(type)}. Please provide a valid one:`, '', ...generateTypes.map(t => `  - ${t}`));
        }
    }
    catch (error) {
        if (error instanceof file_system_1.ClientError) {
            displayError(error.message);
            return;
        }
        throw error;
    }
});
commander_1.program
    .command('rmdir')
    .argument('<name>', 'Name of the directory to remove')
    .description('Remove a directory and all its contents, including any subdirectories and files.')
    .action(async (name) => {
    try {
        await (0, rmdir_1.rmdir)(name);
    }
    catch (error) {
        if (error.code === 'ENOTDIR') {
            displayError(error.message);
            return;
        }
        throw error;
    }
});
commander_1.program
    .command('upgrade')
    .argument('[version]', 'Name of the specific version to upgrade to')
    .description('Upgrade the project to the latest version of FoalTS. If a version is provided, upgrade to that version.')
    .option('-I, --no-install', 'Don\'t autoinstall packages using yarn or npm (uses first available)')
    .action(async (version, options) => {
    await (0, generate_1.upgrade)({ version, autoInstall: options.install });
});
commander_1.program
    .on('command:*', (commands) => {
    commander_1.program.outputHelp();
    displayError(`Unknown command ${(0, safe_1.yellow)(commands[0])}.`);
});
commander_1.program.parse(process.argv);
